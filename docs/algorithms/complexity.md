> 高级工程师title的我，最近琢磨着好好刷刷算法题更高级一些，然鹅，当我准备回忆大学和面试时候学的数据结构之时，我发现自己对这个算法复杂度的记忆只有OOOOOooo
>
> 文章收录在 GitHub [JavaKeeper](https://github.com/Jstarfish/JavaKeeper) ，N线互联网开发必备技能兵器谱

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。

## **时间复杂度**

一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或「**时间频度**」。记为T(n)。

时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。算法的时间复杂度也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称「**时间复杂度**」。

这种表示方法我们称为「 **大O符号表示法** 」，又称为**渐进符号**，是用于描述函数渐进行为的数学符号

常见的时间复杂度量级有：

- 常数阶$O(1)$
- 线性阶$O(n)$
- 平方阶$O(n^2)$
- 立方阶$O(n^3)$
- 对数阶$O(logn)$
- 线性对数阶$O(nlogn)$
- 指数阶$O(2^n)$

#### 常数阶$O(1)$

$O(1)$，表示该算法的执行时间（或执行时占用空间）总是为一个常量，不论输入的数据集是大是小，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```java
int i = 1;
int j = 2;
int k = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用$O(1)$来表示它的时间复杂度。

#### 线性阶$O(n)$

$O(n)$，表示一个算法的性能会随着输入数据的大小变化而线性变化，如

```java
for (int i = 0; i < n; i++) {
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用$O(n)$来表示它的时间复杂度。

#### 平方阶$O(n^2)$

$O(n²)$ 表示一个算法的性能将会随着输入数据的增长而呈现出二次增长。最常见的就是对输入数据进行嵌套循环。如果嵌套层级不断深入的话，算法的性能将会变为立方阶$O(n^3)$，$O(n^4)$，$O(n^k)$以此类推

```java
for(x=1; i<=n; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

#### 指数阶$O(2^n)$

$O(2^n)$，表示一个算法的性能会随着输入数据的每次增加而增大两倍，典型的方法就是裴波那契数列的递归计算实现

```java
int Fibonacci(int number)
{
    if (number <= 1) return number;

    return Fibonacci(number - 2) + Fibonacci(number - 1);
}
```

#### 对数阶$O(logn)$

```java
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

上面的代码，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了，直到i不小于n退出。我们试着求解一下，假设循环次数为x，也就是说 2 的 x 次方等于 n，则由2^x=n得出x=log₂n。因此这个代码的时间复杂度为$O(logn)$

#### 线性对数阶$O(nlogn)$

线性对数阶$O(nlogn) $，就是将时间复杂度为对数阶$O(logn)$的代码循环n遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了$O(nlogn)$，如下，

```java
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

除此之外，其实还有平均情况复杂度、最好时间复杂度、最坏时间复杂度。。。一般没有特殊说明的情况下，都是值最坏时间复杂度。

------



## **空间复杂度**

空间复杂度（Space Complexity）是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。

一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。

一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。当一个算法的空间复杂度与n成线性比例关系时，可表示为$0(n)$，类比时间复杂度。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)

#### 空间复杂度 $O(1)$

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

#### 空间复杂度 $O(n)$

```java
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

------



## 复杂度速查表

来源：https://liam.page/2016/06/20/big-O-cheat-sheet/    源地址：https://www.bigocheatsheet.com/

#### 图例

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbecysa6qj319w01w0sy.jpg)

#### 大-O 复杂度曲线

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbed227xkj317s0qy77v.jpg)

#### 抽象数据结构的操作复杂度

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbed4ehcnj30xz0u0n4m.jpg)



#### 数组排序

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbeda0vscj316f0u0jx3.jpg)

#### 图操作

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbede8tjnj31ac08gwg1.jpg)

#### 堆操作

![](https://tva1.sinaimg.cn/large/00831rSTly1gcbedhhqq0j31a40j8n0w.jpg)





## 参考

《大话数据结构》
https://zhuanlan.zhihu.com/p/50479555



![](https://tva1.sinaimg.cn/large/00831rSTly1gd73fpmmbwj30ku0aumy2.jpg)